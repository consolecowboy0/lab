---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```
# lab <img src='man/figures/logo.png' align="right" height="139" />

<!-- badges: start -->
[![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://www.tidyverse.org/lifecycle/#experimental)
<!-- badges: end -->

The goal of **lab** is to provide useful functionality for experimenting with the development of machine learning and articifical intelligence related algorithms. Specifically, lab serves as a laboratory for developing novel ML/RL/AI methods.

## Installation

You can install the released version of **lab** from [CRAN](https://CRAN.R-project.org) with:

``` r
# install.packages("lab") coming soon!
```

And the development version from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("mtnman38/lab")
```

## Usage

The purpose of **lab** is to help you get started developing, experimenting, and testing different ML/RL/AI solutions on a variety of basic problems. What's the point of this? Well, having a consistent structure to test a new method on allows you to easily reproduce results and understand when and how a certain method fails. This is obviously useful if you are interested in developing novel methods.

Let's look at a very simple example that illustrates how to use this package. We will use the built in goose_game S3 class to see if we can build a very simple model to allow to goose to navigate the obstacles in the goose race. **lab** provides you with simple tools to get started, as well as importing a variety of handy libraries.

We first will initialize a goose_race and take a look at what we have.

```{r}
library(lab)
library(tidyverse)

gr <- goose_race()
gr
```

You can see that we initialize a large 10x10 grid (stored in $locations as a tibble) along with a few other parameters, such as the starting
and ending point of the goose race. The goal is to try and develop an algorithm to get the goose to the end of the race. 

Let's start by writing a function that extracts some features for us from our goose's environment.
```{r}
extract_features <- function(gr) {
  obstacle_df <- look(gr)
  if (nrow(obstacle_df) > 0)
    obstacle_df$obstacle_present <- TRUE
  around_df <- tibble::tibble(x = c(gr$current_location[1] + 1,
                                    gr$current_location[1] - 1,
                                    gr$current_location[1] + 0,
                                    gr$current_location[1] + 0),
                              y = c(gr$current_location[2] + 0,
                                    gr$current_location[2] - 0,
                                    gr$current_location[2] - 1,
                                    gr$current_location[2] + 1),
                              direction = c("north", "south", "east", "west"))
  feature_df <- dplyr::left_join(around_df, obstacle_df, by = c("x", "y"))
  if (nrow(obstacle_df) == 0)
    feature_df$obstacle_present <- FALSE
  feature_df$obstacle_present[is.na(feature_df$obstacle_present)] <- 0
  feature_df %>%
    dplyr::select(direction, obstacle_present) %>%
    tidyr::pivot_wider(names_from = direction, values_from = obstacle_present) %>%
    mutate(current_x = gr$current_location[1], current_y = gr$current_location[2])
}
```






